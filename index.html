<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sovereign Alchemist: Rage Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        #input_video { position: absolute; bottom: 10px; right: 10px; width: 120px; transform: scaleX(-1); opacity: 0; pointer-events: none; }
        #ui { position: absolute; top: 20px; left: 20px; color: #0ff; pointer-events: none; z-index: 10; text-shadow: 0 0 5px #0ff; }
        .hud-box { background: rgba(0, 255, 255, 0.1); border-left: 3px solid #0ff; padding: 10px; margin-bottom: 5px; transition: 0.2s; }
        .rage-mode { border-left: 3px solid #f00 !important; background: rgba(255, 0, 0, 0.2) !important; color: #f00 !important; text-shadow: 0 0 8px #f00 !important; }
        canvas#matrix { position: absolute; top: 0; left: 0; z-index: -1; }
    </style>
</head>
<body>
    <canvas id="matrix"></canvas>
    <div id="ui">
        <div id="sys-box" class="hud-box">SYSTEM: <span id="status">INITIATING...</span></div>
        <div id="bio-box" class="hud-box">BIO-STREAM: <span id="sub-status">AWAITING CLICK</span></div>
    </div>
    <video id="input_video" autoplay playsinline muted></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js"></script>
    <script type="importmap"> { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } } </script>

    <script type="module">
        import * as THREE from 'three';

        // --- MATRIX BACKGROUND ---
        const mCanvas = document.getElementById('matrix');
        const mCtx = mCanvas.getContext('2d');
        let mWidth, mHeight, mCols;
        const mChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$+-*/=%<>#!&";
        const mFontSize = 16;
        let mDrops = [];

        function initMatrix() {
            mWidth = window.innerWidth; mHeight = window.innerHeight;
            mCanvas.width = mWidth; mCanvas.height = mHeight;
            mCols = Math.floor(mWidth / mFontSize);
            mDrops = Array(mCols).fill(1);
        }
        window.addEventListener('resize', () => {
            initMatrix();
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        initMatrix();

        function drawMatrix(isRaging) {
            // If raging, trail fades faster (0.2) for chaos, else smooth (0.08)
            mCtx.fillStyle = isRaging ? "rgba(0, 0, 0, 0.2)" : "rgba(0, 0, 0, 0.08)";
            mCtx.fillRect(0, 0, mWidth, mHeight);
            
            mCtx.fillStyle = isRaging ? "#F00" : "#0F0"; // Red or Green
            mCtx.font = mFontSize + "px monospace";
            
            for (let i = 0; i < mDrops.length; i++) {
                const text = mChars[Math.floor(Math.random() * mChars.length)];
                mCtx.fillText(text, i * mFontSize, mDrops[i] * mFontSize);
                
                // Random reset to top
                if (mDrops[i] * mFontSize > mHeight && Math.random() > 0.975) mDrops[i] = 0;
                
                // Speed: Increment by 1 normally, or 3 if raging
                mDrops[i] += isRaging ? 3 : 1;
            }
        }

        // --- AUDIO ENGINE ---
        let audioCtx, analyser, dataArr, audioActive = false;
        async function startAudio() {
            if (audioActive) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const source = audioCtx.createMediaStreamSource(stream);
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 256;
                dataArr = new Uint8Array(analyser.frequencyBinCount);
                source.connect(analyser);
                audioActive = true;
                document.getElementById('sub-status').innerText = "SENSORS ACTIVE";
            } catch(e) { console.log("Audio permission denied"); }
        }
        window.addEventListener('click', startAudio);

        // --- THREE.JS SCENE ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 25;
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.domElement.style.pointerEvents = 'none';
        document.body.appendChild(renderer.domElement);

        const ptsPerEntity = 489;
        const entities = 3;
        const totalPoints = ptsPerEntity * 3;
        const geometry = new THREE.BufferGeometry();
        const posAttr = new Float32Array(totalPoints * 3);
        const colAttr = new Float32Array(totalPoints * 3);
        geometry.setAttribute('position', new THREE.BufferAttribute(posAttr, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colAttr, 3));

        const material = new THREE.PointsMaterial({ size: 0.16, vertexColors: true, blending: THREE.AdditiveBlending, depthTest: false });
        const cloud = new THREE.Points(geometry, material);
        scene.add(cloud);

        // Safe Fallback for Facemesh Connectivity
        const faceConn = (typeof FACEMESH_TESSELATION !== 'undefined') ? FACEMESH_TESSELATION : 
                         (window.FaceMesh && window.FaceMesh.FACEMESH_TESSELATION) ? window.FaceMesh.FACEMESH_TESSELATION : [];

        const lineGeo = new THREE.BufferGeometry();
        const linePos = new Float32Array((faceConn.length || 0) * 2 * 3);
        lineGeo.setAttribute('position', new THREE.BufferAttribute(linePos, 3));
        const lineMat = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.3, blending: THREE.AdditiveBlending, depthTest: false });
        const wireframe = new THREE.LineSegments(lineGeo, lineMat);
        scene.add(wireframe);

        let faceData, LHand, RHand;
        const L_EYE = [469, 470, 471, 472], R_EYE = [474, 475, 476, 477];

        // --- AI ENGINE (Force Start Logic) ---
        const holistic = new Holistic({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`});
        holistic.setOptions({ modelComplexity: 1, smoothLandmarks: true });
        holistic.onResults(res => { 
            faceData = res.faceLandmarks; 
            LHand = res.leftHandLandmarks; 
            RHand = res.rightHandLandmarks; 
        });

        const video = document.getElementById('input_video');
        async function startCamera() {
            try {
                // Video only here, Audio handled separately to prevent feedback loops
                const s = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
                video.srcObject = s;
                video.onloadedmetadata = () => {
                    video.play();
                    document.getElementById('status').innerText = "AI LOADING...";
                    const detect = async () => { 
                        if (video.readyState >= 2) await holistic.send({image: video}); 
                        requestAnimationFrame(detect); 
                    };
                    detect();
                };
            } catch (err) {
                document.getElementById('status').innerText = "CAM ERROR";
            }
        }
        startCamera();

        function animate() {
            // 1. Calculate Volume and Rage State
            let vol = 0;
            if (audioActive && analyser && dataArr) {
                analyser.getByteFrequencyData(dataArr);
                vol = dataArr.reduce((a,b) => a+b, 0) / dataArr.length;
            }
            
            // THRESHOLD: If volume > 35, Trigger Rage
            const isRaging = vol > 35;
            
            // Update HUD Styles
            const hud1 = document.getElementById('sys-box');
            const hud2 = document.getElementById('bio-box');
            if (isRaging) {
                hud1.classList.add('rage-mode');
                hud2.classList.add('rage-mode');
                hud1.innerHTML = "SYSTEM: <span id='status'>CRITICAL SURGE</span>";
            } else {
                hud1.classList.remove('rage-mode');
                hud2.classList.remove('rage-mode');
                // Only reset text if we are actually online
                if(faceData) hud1.innerHTML = "SYSTEM: <span id='status'>SOVEREIGN ONLINE</span>";
            }

            // Draw Matrix with current state
            drawMatrix(isRaging);
            
            requestAnimationFrame(animate);

            const p = geometry.attributes.position.array;
            const c = geometry.attributes.color.array;
            const lp = lineGeo.attributes.position.array;
            const nod = vol * 0.15;
            const glow = 1 + (vol / 40);

            if (faceData) {
                let lpIdx = 0;
                for (let e = 0; e < 3; e++) {
                    const base = e * ptsPerEntity * 3;
                    const entX = (e === 0) ? 0 : (e === 1 ? (LHand ? (LHand[9].x-0.5)*-40 : -15) : (RHand ? (RHand[9].x-0.5)*-40 : 15));
                    const entY = (e === 0) ? 0 : (e === 1 ? (LHand ? (LHand[9].y-0.5)*-30 : -8) : (RHand ? (RHand[9].y-0.5)*-30 : -8));
                    const scale = (e === 0) ? -40 : -18;
                    
                    // Jitter Effect: If raging, shake the entities
                    const jitter = isRaging ? (Math.random() - 0.5) * 0.5 : 0;

                    for (let i = 0; i < 468; i++) {
                        const idx = base + i * 3;
                        const lm = faceData[i];
                        if (!lm) continue;

                        p[idx] = entX + (lm.x - 0.5) * scale + jitter;
                        p[idx+1] = entY + (lm.y - 0.5) * (scale * 0.8) + nod + jitter;
                        p[idx+2] = lm.z * 10;
                        
                        // Color Logic: Red if raging, else Normal
                        if (isRaging) {
                            c[idx] = 1; c[idx+1] = 0; c[idx+2] = 0; // All Red
                        } else {
                            if (e === 0) { c[idx]=0; c[idx+1]=1; c[idx+2]=1; } // Cyan
                            else if (e === 1) { c[idx]=1; c[idx+1]=0; c[idx+2]=1; } // Magenta
                            else { c[idx]=0; c[idx+1]=1; c[idx+2]=0; } // Green
                        }
                    }
                    
                    // Hands logic (Simplified for brevity, same red logic applies)
                     const hRef = (e === 1) ? LHand : (e === 2 ? RHand : null);
                    for (let i = 0; i < 21; i++) {
                        const idx = base + (468 + i) * 3;
                        if (hRef && hRef[i]) {
                             p[idx] = entX + (hRef[i].x - 0.5) * scale + jitter;
                             p[idx+1] = entY + (hRef[i].y - 0.5) * scale + nod + jitter;
                             p[idx+2] = hRef[i].z * 10;
                             if (isRaging) { c[idx]=1; c[idx+1]=0; c[idx+2]=0; }
                             else { c[idx]=1; c[idx+1]=1; c[idx+2]=1; }
                        } else {
                             p[idx+1] = -100;
                        }
                    }

                    if (e === 0 && faceConn.length > 0) {
                        faceConn.forEach((pair) => {
                            // Robust access for array or object pair
                            const start = pair[0] !== undefined ? pair[0] : pair;
                            const end = pair[1] !== undefined ? pair[1] : pair;
                            
                            const sLM = faceData[start], eLM = faceData[end];
                            if (sLM && eLM) {
                                lp[lpIdx++] = (sLM.x - 0.5) * -40 + jitter; lp[lpIdx++] = (sLM.y - 0.5) * -32 + nod + jitter; lp[lpIdx++] = sLM.z * 10;
                                lp[lpIdx++] = (eLM.x - 0.5) * -40 + jitter; lp[lpIdx++] = (eLM.y - 0.5) * -32 + nod + jitter; lp[lpIdx++] = eLM.z * 10;
                            }
                        });
                    }
                }
            }
            
            // Update line color if raging
            if (isRaging) { lineMat.color.setHex(0xFF0000); lineMat.opacity = 0.8; }
            else { lineMat.color.setHex(0x00FFFF); lineMat.opacity = 0.3; }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            lineGeo.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        } 
        animate();
    </script>
</body>
</html>
